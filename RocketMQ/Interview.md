 **为什么使用消息队列**

 你们公司有个什么业务场景，这个业务场景有个什么技术挑战，如果不用MQ可能会很麻烦，但是你现在用了MQ之后带给了你很多的好处 。



**MQ的优点与缺点**

优点：异步处理，应用解耦，削峰

缺点：

* 可用性降低：考虑MQ宕机的情况

* 复杂性提高：要考虑MQ的消息丢失与重复消费等问题
* 一致性问题：



**MQ对比**

1. 使用场景：Kafka适合日志处理；RocketMQ适合业务处理
2. 性能：Kafka吞吐量更高，单机百万/秒；RocketMQ单机10万/秒， Kafka一个topic有很多partition，代表很多目录，每个目录下有很多segment，每个代表一个消息文件，而RocketMQ存储消息只有commitLog文件 
3.  Kafka不支持定时，事务消息等
4.  Kafka超过64个队列（partition）性能下降严重，而RocketMQ最高支持5万个队列   



**MQ的协议**

JMS：Java消息服务。它便于消息系统中的Java应用程序进行消息交换，并且通过提供标准的产生、发送、接收消息的接口，简化企业应用的开发。ActiveMQ是该协议的典型实现。

 AMQP： 应用 层标准。。 RabbitMQ是该协议的典型实现。



**怎么保证消息不丢失**

1. 消费者保证投递发送成功

生产者有三种发送方式：同步、异步和OneWay。同步就是发送消息后进入阻塞，等待确认，异步就是异步的，发送后直接返回，消息发送成功后回掉自定义的接口，Oneway就是只管发送。

生产者采用同步的方式确保发送到了MQ，发送失败时可以指定重试次数，最后还不行就存入DB。

2. Broker确保持久化

Broker的刷盘策略分为同步和异步。同步是等消息持久化后再返回ACK，异步是指将消息写入PageCache后直接放回。可以采用同步刷盘的策略，确保消息被持久化。另外，MQ应该采用多主多从的方式来保证高可用，采用同步双写(主从都持久化后再返回ACK)。

3. 消费者。 消费完成后，才向服务器返回ack 



**RocketMQ怎么避免消息重复消费**

消息重复消费的原因，如何做幂等



**RocketMQ怎么使用顺序消息**



**消息堆积怎么办**

1. 消费者问题。消费者挂了需要重启；Topic中消息队列的数量大于消费者的数量，这时候可以考虑添加消费者(如果有DB等操作，要考虑下游是否支撑得住)
2. MQ问题。Topic中消息队列的数量小于消费者的数量，这时候添加消费者是没有用的。这时应该新建Topic指定消息队列的数量，然后将消息转移到新的Topic中，最后添加消费者，消费新Topic中的消息。



**消息怎么过滤**

1. 通过Tag过滤
2. 通过SQL



**消息是如何发送的**



**消费者如何接收消息**







**消息基于什么传输的**



**如何确保消息被接受了**



**消息补偿机制是什么**



**怎么设计一个MQ**

1. 可伸缩
2. 持久化
3. 高可用



**死信队列的原因，使用**



**延迟队列的使用**



**优先级队列**



**事务消息**



**消费者因某些原因无法解决的消息怎么办**