# Redis



**你用过redis中的哪些数据类型**

String：计数场景

List：双向链表，消息队列，订阅模式

hash：键值对

set：存放不重复数据以及获得交集并集

sorted set：与set相比多了score字段，可以根据score字段进行排序





**redis的场景数据类型和应用场景**



## **持久化**



**RDB与AOF的对比**

RDB：将某个时间点的所有数据都存放到硬盘上。会丢失一段时间的数据

AOF：将写命令添加到 AOF 文件（append only file末尾。会丢失最后一步数据

如果系统发生故障，将会丢失最后一次创建快照之后的数据。

如果数据量大，保存快照的时间会很长。



**如何利用Redis锁解决高并发问题**



## 主从复制



**使用流程：**



**工作流程：**

1、从服务发送一个 sync 同步命令给主服务要求全量同步
2、主服务接收到从服务的 sync 同步命令时，会 fork 一个子进程后台执行 bgsave 命令（非阻塞）快照保存，生成 RDB 文件，并将
RDB 文件发送给从服务
3、从服务再将接收到的 RDB 文件载入自己的 redis 内存
4、待从服务将 RDB 载入完成后，主服务再将缓冲区所有写命令发送给从服务
5、从服务在将主服务所有的写命令载入内存从而实现数据的完整同步
6、从服务下次在需要同步数据时只需要发送自己的 offset 位置（相当于 mysql binlog 的位置） 即可，只同步新增加的数据，再不需要全量同步



redis 的哨兵机制的作用?

1、监控:Sentinel 会不断的检查主服务器和从服务器是否正常运行。
2、通知:当被监控的某个 redis 服务器出现问题，Sentinel 通过 API 脚本向管理员或者其他的应用程序发送通知。
3、自动故障转移:当主节点不能正常工作时，Sentinel 会开始一次自动的故障转移操作，它会将与失效主节点是主从关系 的其中一个从节点升级为新的主节点，并且将其他的从节点指向新的主节点。



## 热点问题



**Redis和Memcache 的区别**

* 数据类型
* 持久化



**内存淘汰策略**

已过期/未过期，最近最少/随机，将过期/不删除

1. volatile-lru(least recently used):从已设置过期时间的数据集(server.db[i].expires) 中挑选最近最少使用的数据淘汰
2. volatile-ttl:从已设置过期时间的数据集(server.db[i].expires)中挑选将要过期的数据淘汰
3. volatile-random:从已设置过期时间的数据集(server.db[i].expires)中任意选择数据淘汰
4. allkeys-lru(least recently used):当内存不足以容纳新写入数据时，在键空间中，移除
   最近最少使用的 key(这个是最常用的)
5. allkeys-random:从数据集(server.db[i].dict)中任意选择数据淘汰
6. no-eviction:禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报
   错。这个应该没人使用吧!



**缓存穿透**

访问不存在的key，每次都穿过缓存去查数据库

解决方案：

首先需要参数校验

1. 缓存无效的key：把无效的 ID，也在 redis 缓存起来，并设置一个很短的超时时间
2. 布隆过滤器：布隆过滤器说某个元素存在，某个元素可能小概率不存在，说某个元素不存咋，某个元素就一定不存在。



**缓存击穿**

解决方案：

1. 热点数据设置永不超时
2. 对访问的 Key 加上互斥锁，请求的 Key 如果不存在，则加锁，去数据库取，新请求过来，如果相同 KEy,则暂停 10s 再去缓存取值；如果 Key 不同，则直接去缓存取！



**缓存雪崩**



**redis为什么单线程还这么快**

1. 单线程编程容易并且更容易维护;
2. Redis 的性能瓶颈不再 CPU ，主要在内存和网络;
3. 多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能



**Redis为什么又加入了多线程**

为了提高网络IO读写能力

虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用
了， 执行命令仍然是单线程顺序执行



**redis缓存和数据库的数据不一致怎么解决**

出现不一致的原因：两个请求，一个写一个读，写没刷入数据库时，一个请求进行了读取，刷新到了Redis

解决方案：***缓存双淘汰法***。先淘汰缓存



