**一群人围成一个圈，依次1，2，3报数，数到3的人出列，求最后出列的那个人的编号**





**手写单例模式(饿汉与懒汉)**



**排序算法**



**斐波那契数列** 



**⼀只⻘蛙⼀次可以跳上1级台阶，也可以跳上2级。求该⻘蛙跳上⼀个n级的台阶总共有多少种跳法** 



**⼀只⻘蛙⼀次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该⻘蛙跳上⼀个n级的 台阶总共有多种跳法**

 



# 字符串



**最大子序和**

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和

遍历数组，计算前n项的和如果大于0就取前n项和+当前元素，否则为0+当前元素



 **最长公共连续子串**

 给出两个字符串（可能包含空格）,找出其中最长的公共连续子串,输出其长度 



**给定⼀个字符串 s，找到 s 中最⻓的回⽂⼦串**

马拉车算法，中心扩展算法

```java
public static String longestPalindrome(String s) {
        if(s.length() < 2){
            return s;
        }
        int maxLength = 0; //最大回文数长度
        int center = 0; //中心点
        for(int i = 0; i < s.length(); i++){
            int len1 = centerExpand(s, i, i); //回文数为奇数情况
            int len2 = centerExpand(s, i, i + 1); //回文数为偶数情况
            if(maxLength < Math.max(len1, len2)) {
                center = i;
                maxLength = Math.max(len1, len2);
            }
        }
        return s.substring(center - (maxLength - 1) / 2, center + maxLength / 2 + 1);
    }

    /**
     * 给定一个中心点，并向两边拓展到以该点为中心的最大的回文数的长度
     * @param s
     * @param left
     * @param right
     * @return
     */
    public static int centerExpand(String s, int left, int right){
        while(left > 0 && right > s.length() && s.charAt(left) == s.charAt(right)){
            left--;
            right++;
        }
        return right - left - 1;
    }
```







**编写⼀个函数来查找字符串数组中的最⻓公共前缀。如果不存在公共前缀，返回 空字符串 ""** 

循环遍历



**给定⼀个包含⼤写字⺟和⼩写字⺟的字符串，找到通过这些字⺟构造成的最⻓的回⽂串。** 

记录每个字符出现的次数，对于偶数的字符，直接加上出现的次数，对于奇数的字符，加上减一的次数。最后判断是否出现过奇数的字符，如果出现过至少一次，结果再加一 



**给定⼀个字符串，验证它是否是回⽂串，只考虑字⺟和数字字符，可以忽略字⺟ 的⼤⼩写。 说明：本题中，我们将空字符串定义为有效的回⽂串** 





# 数组



**在⼀个⼆维数组中，每⼀⾏都按照从左到右递增的顺序排序，每⼀列都按照从上到下递增的顺序 排序。请完成⼀个函数，输⼊这样的⼀个⼆维数组和⼀个整数，判断数组中是否含有该整数。** 

矩阵是有序的，从左下⻆来看，向上数字递减，向右数字递增， 因此从左下⻆开始查找，当要查找数字⽐左下⻆数字⼤时。右移 要查找数字⽐左下⻆数字⼩时，上移。这样找的速度最快。 



**数组A，2*n个元素，n个奇数、n个偶数，设计⼀个算法，使得数组奇数 下标位置放置的都是奇数，偶数下标位置放置的都是偶数**



**给出两个升序数组A，B和长度m，n，求K个大的**





# 链表

 

**输⼊两个单调递增的链表，输出两个链表合成后的链表** 



**⼿写⼀个对象池**



**反转链表** 



**反转部分链表**



# 树



前序中序后序遍历，已知中序前序求二叉树，已知中序后序求二叉树

前中后指的是根节点的位置。



