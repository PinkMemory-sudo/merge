# 

# 备份与恢复

# 高可用

# 内置函数

# 缓存



## 游标

不常用  



**什么是游标**

是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。



**一条SQL语句在MySQL中如何执行的**

[一条SQL语句在MySQL中如何执行的](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485097&idx=1&sn=84c89da477b1338bdf3e9fcd65514ac1&chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&token=79317275&lang=zh_CN%23rd)



**bin-log日志**



**InnoDB的page**

一般16k



## 性能优化

* 加索引
* 避免返回不必要的字段
* 
* 适当分批操作
* 分库分表
* 读写分离



**MySQL高性能优化规范建议**

[MySQL高性能优化规范建议](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485117&idx=1&sn=92361755b7c3de488b415ec4c5f46d73&chksm=cea24976f9d5c060babe50c3747616cce63df5d50947903a262704988143c2eeb4069ae45420&token=79317275&lang=zh_CN%23rd)



[腾讯面试:一条SQL语句执行得很慢的原因有哪些?---不看后悔系列](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485185&idx=1&sn=66ef08b4ab6af5757792223a83fc0d45&chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&token=79317275&lang=zh_CN%23rd)



[后端程序员必备:书写高质量SQL的30条建议](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486461&idx=1&sn=60a22279196d084cc398936fe3b37772&chksm=cea24436f9d5cd20a4fa0e907590f3e700d7378b3f608d7b33bb52cfb96f503b7ccb65a1deed&token=1987003517&lang=zh_CN%23rd)





**大表优化**

[大表优化方案](https://segmentfault.com/a/1190000006158186)

当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常⻅的优化措施如下：

* 限定数据的范围：务必禁止不带任何限制数据范围条件的查询语句。
* 读**/**写分离：主库负责写，从库负责读;
* 垂直分区：把一张列比较多的表拆分为多张表。
* 水平分区：保持数据表结构不变，每一片数据分散到不同的表或者库中，分表仅仅是解决了单一表数据过大的问 题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 水平拆分最好分库。



**垂直分表和水平分表的优缺点**

垂直分表

可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。但主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用 层进行Join来解决。此外，垂直分区会让事务变得更加复杂;

水平分表

支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨节点Join 性能􏰁差，逻辑复杂



**数据库分片的两种常⻅方案**

* 客户端代理: 分片逻辑在应用端，封装在**jar**包中，通过修改或者封装**JDBC**层来实现。 当 当网的 **Sharding-JDBC** 、阿里的TDDL是两种比􏰁常用的实现。
* 中间件代理: 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我 们现在谈的 **Mycat** 、360的Atlas、网易的DDB等等都是这种架构的实现。



**分库分表之后,id 主键如何处理**

因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的id 来支持。

* UUID:不适合作为主键，因为太⻓了，并且无序不可读，查询效率低。比􏰁适合用于生成 唯一的名字的标示比如文件的名字。
* 数据库自增 id : 两台数据库分别设置不同步⻓，生成不重复ID的策略来实现高可用。这种方 式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。
* 利用 redis 生成 id : 性能比􏰁好，灵活方便，不依赖于数据库。但是，引入了新的组件造成 系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。
* Twitter的snowflake算法 :Github 地址:https://github.com/twitter-archive/snowflake。 美团的Leaf分布式ID生成系统 :Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、 趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系 数据库、Zookeeper等中间件。感觉还不错。美团技术团队的一篇文章:https://tech.meitua n.com/2017/04/21/mt-leaf.html 。



## **SQL优化**



* 不要使用select *，查什么写上，查全部使MySQL优化器失去了索引覆盖的可能，增加了IO和网络开销
* 避免使用in,not in,会使数据库进行全表扫描，连续值可以用between代替，子查询可以用exists代替
* 尽量避免进行 null 值的判断，会导致数据库引擎放弃索引进行全表扫描。优化方式：可以给字段添加默认值 0，对 0 值进行判断。
* 避免左模糊查询



**分库分表的设计**



**limit100000分页很慢怎么解决**

* 如果id是连续的，可以通过添加where条件id>100000



**查询缓冲**

修改配置文件开启缓冲，当查询的表和查询条件都没有变化时可以使用缓存，否则缓存失效。MySQL 8.0 版本后移除，因为这个功能不太实用，缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一 次缓存操作，失效后还要销毁。





**B+树的叶子节点都存放了哪些数据**

可能存储的时整行的数据(主键索引，聚簇索引)，也可能时主键的值



**B树与B+树的区别**



**B树和hash的对比**

hash索引的底层数据结构是hash表，是以键值对的形式存储的，所以进行等值查询的效率高，但是进行区间查询时就需要扫描全表。

B+树是一种多路平衡查找树，他的节点是有序的，进行范围查询不用扫描全表。



**B树和平衡二叉树的区别**







**什么样的字段适合建立索引**

* 经常作为查询条件以及排序和分组条件，联结条件的
* 值差异性大的
* 索引的字段的值很长时，最好使用字段值的前缀来进行索引(创建索引时，在索引的字段后加括号指定长度)， MySQL中无法使用前缀索引进行ORDER BY和GROUP BY 
* 不能创建过多的索引，删除不要的索引，尽量扩展索引而不是新建索引



IO次数就是树的高度



**磁盘页**



**Hash 索引和 B+树索引的区别**



**为什么不都用 Hash 索引而使用 B+树索引**



**B 树和 B+树的区别**



* 红黑树？

**一个B+树的节点中到底存多少个元素最合适**



Mysql的基本存储结构是**页**



B Tree又称为平衡多路查找树



**JDBC使用步骤**



 

空闲连接

wait_timeout

缓存

**query_cache_type**

```mysql
select SQL_NO_CACHE * from B
```

缓存在MySQL8.0之后就**取消**了



