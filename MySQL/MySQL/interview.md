# 数据类型



**varchar(50)中50的含义**

最多存放50字符



**int(20)中20的含义**

类型为int，显示的最大长度是20



**ENUM**

ENUM在存储时实际存储的时整数



**Blog和Text的区别**

BLOB保存二进制数据,TEXT保存字符数据



**记录货币用什么类型好**

常用Decimal和Numric类型表示，这两种类型被MySQL实现为同样的类型。DECIMAL(9,2)9表示整数和小数的一共可以有几位，2表示小数有多少位



**要存储身份证号，要使用什么类型**

像大小固定的字段，可以使用char而不是varchar，这样可以节省空间，提高检索效率。密码散列,用户身份证号等固定长度的字符串应该使用char而不是varchar来存储, 这样可以节省空间且提高检索效率。



**DATETIME与TIMESTAMP的区别**

都是精确到s

1. DATETIME的范围是1001-9999年，TIMESTAMP的时间范围是1970-2038
3. DATETIME占8字节，TIMESTAMP占4字节



**怎么获得当前日期**

NOW()和CURRENT_DATE().CURRENT_DATE()仅显示年月日



**MySQL的创建时间和修改时间怎么自动更新**

方案1：创建表的时候指定

```mysql
...
`create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
`update_time` datetime DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间'
...
```

方案2：修改字段

```mysql
ALTER TABLE `course`
MODIFY COLUMN `create_time` datetime NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间' ;
ALTER TABLE `course`
ADD COLUMN `update_time` datetime NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间' ;
```



**数据库是否支持emoji表情存储**

更改字符集 utf8->utf8mb4



# 增删改



**MySQL自增ID用完怎么办**

ID就不自增了，然后就主键冲突了。

id范围够大了，分库分表也不使用自增的Id。



找到最后一次插入是分配的自增ID



一个6亿数据的表A和3亿数据的表B，怎么快速查询处第50000到50200的数据





**TRUNCATE与DELETE的区别**

* TRUNCATE用来清空整张表，效率高
* 自增约束，TRUNCATE从1开始，DELETE继续往后
* TRUNCATE不支持回滚
* TRUNCATE后没有返回值，DELETE后返回受影响的函数



**drop，delete与truncate的区别**

从执行速度上来说 drop > truncate >> DELETE

truncate删除操作不会记录日志，所以不会恢复

drop是删除整个表，包括表结构



**内连接，外链接什么意思**

内连接：只连接匹配的行

外连接分为左外连接，右外连接和全连接



**count(*)、count(1)、count(column)的区别**

执行结果：count(*)和count(1)没有区别，都不会过滤空值，count(column)不包含空值

执行效率：MyISAM 引擎会把一个表的总行数记录了下来，所以在执行 count(*) 的时候会直接返回数量，执行效率很高，5.5后MySQL的默认存储引擎是InnoDB，因为增加了版本控制(MVCC)的原因，同时有多个事务访问数据并且有更新操作的时候，每个事务需要维护自己的可见性，那么每个事务查询到的行数也是不同的，所以不能缓存具体的行数，他每次都需要 count 一下所有的行数。`InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way There is no performance difference`



# 查询



**一条SQL语句在MySQL中如何执行的**

[一条SQL语句在MySQL中如何执行的](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485097&idx=1&sn=84c89da477b1338bdf3e9fcd65514ac1&chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&token=79317275&lang=zh_CN%23rd)



**in和exists的区别**



**JDBC使用步骤**

1. 加载驱动
2. 创建连接
3. 获得statement/pre...对象
4. 执行SQL
5. 获得结果集



**什么是SQL预编译**

 很多情况下，一条SQL语句可能会反复执行，或者每次执行的时候只有个别的值不同。指的是数据库驱动在发送 sql 语句和参数给 DBMS 之前对 sql 语句进行编译，这样 DBMS 执行 sql 时，就不需要重新编译。 



 **PreparedStatement为什么能在一定程度上防止SQL注入？** 

 在使用参数化查询的情况下，数据库不会将参数的内容视为SQL执行的一部分，而是作为一个字段的属性值来处理，这样就算参数中包含破环性语句（or ‘1=1’）也不会被执行。



**关联查询*

1. 内连接
2. 外连接：左外连接和有外连接
3. 实现全连接：



**UNION与UNION ALL的区别**

UNION对两个结果集并集，不包含重复行，同时进行默认规则的排序

UNION ALL对两个结果集进行并集操作，包含重复行，不进行排序。



# 约束



**超键，候选键是什么**

超键：能唯一标识一条记录的

候选键：最小的超键，没有冗余的元素



**SQL有几种约束**

1. NOT NULL
2. UNIQUE
3. PRIMARY KEY
4. FOREIGN KEY 防止破坏表之间关系和非法插入
5. CHECK



**字段为什么要定义为NOT NULL**

null值会占用更多的资源并且会使索引失效



# 索引



**B树和B+树的区别**

而B+树的非叶子节点只存储key不存储data，这样每个节点中能存储更多key，降低树的高度，减少IO

B+树的叶子节点通过指针相连，容易进行顺序访问



**为什么是B+树**

单一节点可以存储更多节点，减少IO次数

所有查询都需要查询到叶子节点，查询性能稳定

所有叶子节点相连，便于范围查询



**索引的分类**

* 普通索引
* 主键索引
* 唯一索引
* 组合索引
* 全文索引(MyISAM支持，只能作用在char，varchar和text。)



**聚簇索引和非聚簇索引的区别**

数据即索引，数据的存储和索引对应，找到索引时就能直接取出数据，所以局促索引只能有一个

非聚簇索引叶子节点存放聚簇索引中的key，需要根据key再从聚簇索引中查。



**索引覆盖**

就是select的字段都在索引中，就不需要进行回表操作了(比如只查询id)。



**索引下推**

MySQL5.6引入了索引下推。

索引下推的作用就是减少了回表的操作。

没有ICP的情况

- 存储引擎读取索引记录；
- 根据索引中的主键值，定位并读取完整的行记录；
- 存储引擎把记录交给`Server`层去检测该记录是否满足`WHERE`条件。

使用ICP的情况下，查询过程如下：

- 读取索引记录（不是完整的行记录）；
- 判断`WHERE`条件部分能否用索引中的列来做检查，条件不满足，则处理下一行索引记录；
- 条件满足，使用索引中的主键去定位并读取完整的行记录（就是所谓的回表）；
- 存储引擎把记录交给`Server`层，`Server`层检测该记录是否满足`WHERE`条件的其余部分。



**什么样的字段适合建立索引**

* 经常作为查询条件以及排序和分组条件，联结条件的
* 值差异性大的
* 索引的字段的值很长时，最好使用字段值的前缀来进行索引(创建索引时，在索引的字段后加括号指定长度)， MySQL中无法使用前缀索引进行ORDER BY和GROUP BY 
* 不能创建过多的索引，删除不要的索引，尽量扩展索引而不是新建索引



**怎么删除索引**

`删除索引：DROP INDEX 索引名;`



**怎么查看查询中用到的索引**

`explain`可以查看可用的索引和实际使用的索引



**什么情况索引会失效**

* like以%开头
* or语句前后没有同时使用索引
* 在索引列上使用 IS NULL 或 IS NOT NULL操作。索引是不索引空值的，所以这样的操作不能使用索引
* 在索引字段上使用not，<>，!=。会扫描全表
* 对索引字段进行计算操作、字段上使用函数
* 字符串不加引号，如varchar不加单引号的话可能会自动转换为int型
* 没有使用组合索引的第一列索引
* 当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效



**创建索引的原则**

* 唯一索引
* 经常作为查询，排序，分组等条件的字段
* 限制索引的数量，每次更新时，索引会重建
* 索引字段的值太长的话，可以使用前缀索引
* 删除不再使用或很少使用的索引
* 尽量选择区分度高的列作为索引
* 尽量扩展索引，不要新建索引





**什么样的字段适合建立索引**

* 经常作为查询条件以及排序和分组条件，联结条件的
* 值差异性大的
* 索引的字段的值很长时，最好使用字段值的前缀来进行索引(创建索引时，在索引的字段后加括号指定长度)， MySQL中无法使用前缀索引进行ORDER BY和GROUP BY 
* 不能创建过多的索引，删除不要的索引，尽量扩展索引而不是新建索引





**如何添加索引**

1. 创建表的时候

```mysql
create table ......

primarykey(id)
```

2. ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` )





# 查询



**SQL的执行数据**





# 备份与恢复



# 高可用



# 存储引擎



**什么是存储引擎**



**MyISAM和InnoDB的区别**

|        | 事务                     | 外键                     | 行级锁                   | MVCC                     | 全文索引                 |
| ------ | ------------------------ | ------------------------ | ------------------------ | ------------------------ | ------------------------ |
| MyISAM | :heavy_multiplication_x: | :heavy_multiplication_x: | :heavy_multiplication_x: | :heavy_multiplication_x: | :heavy_check_mark:       |
| InnoDB | :heavy_check_mark:       | :heavy_check_mark:       | :heavy_check_mark:       | :heavy_check_mark:       | :heavy_multiplication_x: |

* 5.5版本后默认的存储引擎为InnoDB，之前是MyISAM
* 事务：MyISAM不支持事务
* 锁： MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row- level locking)和表级锁,默认为行级锁。
* 外键：MyISAM不支持外键
* MVCC：仅InnoBD支持，应对高并发事务, MVCC比单纯的加锁更高效;
* 清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表

MyISAM强调性能，但是也不一定比InnoDB快，尤其是使用到聚簇索引的时候



**使用场景**

* MyISAM适合查询以及插入为主的应用，
* InnoDB适合频繁修改以及涉及到安全性较高的应用

* InnoDB：需要事务和外键约束时，可以冲灾难中恢复



# 事务



**ACID实现的原理**

原子性：使用undo log实现。如果出错或用户执行了rollback，系统通过undo log返回开始的状态

持久性：使用redo log。只要redo log持久化了，系统重启后会冲redo log中恢复数据

隔离性：通过锁及MVVM，使事务相互隔离

一致性：通过回滚，恢复，



**事务的四大特性(ACID)**

* 原子性 将多个操作看成一个操作，要么都成功，要么都失败，失败后回滚，不能对数据库造成影响。
* 一致性 事务前后数据库的完整性约束不会收到破坏
* 隔离性 多个事务间不能相互影响，同一时间只允许一个事务操作同一个数据
* 持久性  事务提交后，接下来的操作或故障不会对持久化的数据造成影响



**什么是赃读幻读不可重读**

* 赃读，读取到其他事务中还没提交的数据，其他数据回滚时读到的数据就是脏数据
* 不可重读，一个事务多次读取数据，期间另一个事务修改了数据，导致读取的数据前后不一样
* 幻读，一个事务读取多行，另一个事务期间插入了几行，导致前后读取到的行数不一致



**事务的隔离级别，MySQL的默认隔离级别是什么**

***读取未提交：***一个事务读取到了另一个事务还没提交的数据，造成赃读，不可重读，和幻读

***读取已提交：***一个事务可以读取已提交的事务，造成不可重读，和幻读

***可重读：***一个事务中多次读取到的结果都是一样的，造成、幻读

***串行读：***完全符合ACID，事务一个一个执行

MySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ**(可重读)

InnoDB虽然采用的是可重读的隔离级别，下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生。

InnoDB 存储引擎在 分布式事务 的情况下一般会用到 **SERIALIZABLE(**可串行化**)** 隔离级别。



# 存储过程



**什么是存储过程，怎么调用**

一组为了完成特定功能预编译的SQL 语句集，一次编译后永久有效。如果某次操作需要执行多句 SQL，使用存储过程比单纯 SQL语句执行要快。
调用：

* 可以用一个命令对象来调用存储过程。

* 可以供外部程序调用，比如：java 程序。



**存储过程的优点**

* 存储过程是预编译过的，执行快。
* 存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。
* 安全性高，执行存储过程需要有一定权限的用户。
* 存储过程可以重复使用，可减少数据库开发人员的工作量。缺点：移植性差





# 触发器



**什么是触发器**

触发器是特殊的存储过程，通过事件触发执行。用来维护数据的完整性和一致性。当出现某个时间时自动执行这些代码。



**使用场景**

* 数据库中的级联操作
* 监控表中的某个字段发生变化时做出相应的处理



**MySQL中有哪些触发器**

1. Before Insert
2. After Insert
3. Before Update
4. After Update
5. Before Delete
6. After Delete







# 视图





**什么是视图**

通俗的讲，视图就是一条SELECT语句执行后返回的结果集，不存储具体的数据，而是存储视图的定义。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。视图是一张虚拟的表，具有和物理表相同的功能，对视图的修改会影响基本表。



**视图的优点**

方便操作，特别是查询操作，减少复杂的SQL语句，增强可读性，视图可以隐藏表表间的复杂关系。

更加安全，数据库授权命令不能限定到特定行和特定列，但是通过合理创建视图，可以把权限限定到行列级别；



**使用场景**

* 授权：客户想要直接查询数据库，不希望用户访问表中某些含敏感信息的列，可以创建视图和用户，将视图授权给用户。

* 表连接：关键信息来源于多个复杂关联表，可以创建视图提取我们需要的信息或者有的时候，由于表中的数据量太大，需要对表进行拆分，这样会导致表的结构发生变化，导致用户的应用程序受到影响，这时我们就可以使用视图来屏蔽实体表间的逻辑关系，去构建应用程序所需要的原始表关系




**视图的分类**

* MERGE：将视图的sql语句和引用视图的sql语句合并在一起，最后一起执行。

* TEMPTABLE： 将视图的结果集存放在临时表中，每次执行时从临时表中操作。

* UNDEFINED： 默认的视图类型，DBMS倾向于选择而不是必定选择MERGE，因为MERGE的效率更高，更重要的是临时表视图不能更新。

所以，这里推荐使用MERGE算法类型视图。



**怎么创建视图**

```mysql
CREATE ALGORITHM = UNDEFINED 
DEFINER = `root`@`localhost` 
SQL SECURITY DEFINER
VIEW `视图名` AS (
    select ...
);
```

ALGORITHM=UNDEFINED：指定视图的处理算法；

DEFINER=`root`@`localhost`：指定视图创建者；

SQL SECURITY DEFINER：指定视图查询数据时的安全验证方式；



**怎么使用视图**

将视图名当成表名

```mysql
select
视图名.属性
from 视图
```





# 内置函数

80道



**获得当前时间**

select current_date()



# 日志



**MySQL的binlog有几种录入格式，有什么区别**





**undolog和redolog的总结**：

事务的运行存储引擎会产生两个log：undolog和redolog，redolog的作用是在事务提交后宕机了，没来得及刷入磁盘，在重启时，可以根据redolog进行恢复，保证了事务的持久性。undolog会记录更新前的数据，用于事务的回滚和MVCC



事务提交后将操作刷如redo log，事务回滚时将执行undo log

redo和undo都是一种恢复操作，redo是物理层的修改记录着物理层上页的修改(页号，偏移量，操作)；undo是逻辑层的修改，会记录一个相反的操作。



## redolog



redo日志降低了刷盘的频率，事务执行过程中，redo log不断记录。



**为什么不直接刷到页中**

* 频繁进行IO操作
* 页可能并不是连续的



**redolog包含两部分：**

*redo log buffer*

保存在内存中，是易失的。服务在启动时就会申请一块空间作为redolog的缓冲区(默认16M)

*redo log file*

保存在硬盘中，是持久的。



**redo的整体流程**

1. 将磁盘中的数据读取到内存，在内存中对数据进行修改

2. 生成一条redo日志并写入redo log buffer，记录的是数据被修改后的值
3. 当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加 写的方式
4. 定期将内存中修改的数据刷新到磁盘中



**redo log刷盘策略**

即buffer什么时候刷如file：定时/每次提交/交给操作系统

redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到 文件系统缓存 (page cache)中去。真正的写入会交给系 统自己来决定。那么对于InnoDB来说就存在一个问题，如果交给系统来同 步，同样如果系统宕机，那么数据也丢失了。针对这种情况，InnoDB给出 innodb_flush_log_at_trx_commit 参数，该参数控制 commit提交事务 时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：

* 设置为0 :表示每次事务提交时不进行刷盘操作。(系统默认masterthread每隔1s进行一次重做日 志的同步
* 设置为1:表示每次事务提交时都将进行同步，刷盘操作(默认)
* 设置为2:表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自
  己决定什么时候同步到磁盘文件。



## undo log

undo log是事务原子性的保证。在事务中增删改之前实际要先写入一个 undo log ，记录更改之前的数据。

undo log的产生也伴随着redolog，因为undolog也需要持久化



**作用**：

* 回滚，undolog记录的是逻辑上的修改，所以数据可以恢复，但是不一定还按照之前的数据页进行存储
* MVCC，当前行被其他事务使用，可以去读取undo日志中保存的数据，以非锁的方式读取



**存储结构**：



事务执行完时undolog不会立马清理，应为可能其他事务正在读取(MVCC)



回滚段？

当数据被修改时，原始的数 据会被复制到回滚段



当事务提交时，InnoDB存储引擎会做以下两件事情

1. 





InnoDB事务与日志实现的原理



有多少种日志







事务回滚机制概述



## bin log



**binlog录入方式**



redo log与binlog的区别

redolog是存储引擎产生的，binlog是数据库产生的，如果一个事务中对十万行记录进行了插入，这个过程中redolog会不断的记录，binlog只在提交的时候才写入binlog





# 锁



**MySQL 三种锁的级别**



**MySQL都有哪些锁**



**隔离级别与锁的关系**



**MySQL的乐观锁悲观锁怎么实现**



**表级锁和行级锁对比**

* 表级锁: MySQL中锁定 粒度最大 的一种锁，对当前操作的整张表加锁，实现简单，资源消 耗也比􏰁少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最 低，MyISAM和 InnoDB引擎都支持表级锁。
* 行级锁: MySQL中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大 大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会 出现死锁。



**乐观锁和悲观锁**

悲观锁如行锁，表锁，读锁，写锁等，都是在做操作之前先上锁。

乐观锁每次去拿数据的时候都认为别人不会修改数据，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据

乐观锁适合在多读的应用类型，这样可以提高吞吐量，如果经常插入，产生冲突的可能性就比较大，上层应用会不断的进行 retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。



**InnoDB存储引擎的三种锁的算法**

* Record lock:单个行记录上的锁

* Gap lock:间隙锁，锁定一个范围，不包括记录本身 
* Next-key lock:record+gap 锁定一个范围，包含记录本身



**行锁和表锁的使用场景**



**MySQL的死锁**



# MVCC



**什么是MVCC**



MVCC本质是采用乐观锁思想进行读数据。利用undolog,readview,隐藏字段实现，主要解决读写冲突。



为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样 在做查询的时候就不用等待另一个事务释放锁，提高数据库并发性能。



读数据时会加锁的情况

```mysql
SELECT * FROM student LOCK IN SHARE MODE; # 共享锁 
SELECT * FROM student FOR UPDATE; # 排他锁
INSERT INTO student values ... # 排他锁
DELETE FROM student WHERE ... # 排他锁
UPDATE student SET ... # 排他锁
```







# 优化



小表驱动大表？



优化长难句有什么实战



优化特定类型的查询



优化关联查询



优化子查询



优化LIMIT分页



优化UNION



优化where



优化distinct



数据库结构的优化



MySQL作为发布系统的存储，一天五万的增量，要维持三年，怎么优化



CPU飙升应该怎么处理



慢查询日志



数据库连接池为什么



数据库性能分析show status



* 是否使用了索引

* 是否返回了不需要的字段
* 表数据量太大，考虑分表



**百万级别以上的数据如何删除**

数据的增删改需要IO索引文件，进行上百万次IO所以可以把索引删了，然后进行增删改，最后再加上索引。



**count(*),count(1)与count(列名)的区别**



**MySQL数据库CPU狂飙，怎么处理**

使用show processlist查看session情况，确定是不是又小号资源的SQL执行。



## 读写分离



**读写分离常见方案**





复制的原理和流程



主从一致校验



主从延迟怎么解决



**主从复制原理**

1. 主库中又个bin-log的二进制文件，记录了所有增删改的SQL语句(binlog线程)
2. 从库将主库的binlog文件复制过来(IO)
3. 从库写入relay-log执行SQL ？



**主从一致性校验**

checksum，MySQLLdiff，pt-table-checksum



**超大分页，怎么处理**

如果ID是自增且连续的，可以在where后添加id的条件

如果不是连续的，就需要使用覆盖索引



**MySQL高性能优化规范建议**

[MySQL高性能优化规范建议](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485117&idx=1&sn=92361755b7c3de488b415ec4c5f46d73&chksm=cea24976f9d5c060babe50c3747616cce63df5d50947903a262704988143c2eeb4069ae45420&token=79317275&lang=zh_CN%23rd)



[腾讯面试:一条SQL语句执行得很慢的原因有哪些?---不看后悔系列](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485185&idx=1&sn=66ef08b4ab6af5757792223a83fc0d45&chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&token=79317275&lang=zh_CN%23rd)



[后端程序员必备:书写高质量SQL的30条建议](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486461&idx=1&sn=60a22279196d084cc398936fe3b37772&chksm=cea24436f9d5cd20a4fa0e907590f3e700d7378b3f608d7b33bb52cfb96f503b7ccb65a1deed&token=1987003517&lang=zh_CN%23rd)





**大表优化**

[大表优化方案](https://segmentfault.com/a/1190000006158186)

当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常⻅的优化措施如下：

* 限定数据的范围：务必禁止不带任何限制数据范围条件的查询语句。
* 读**/**写分离：主库负责写，从库负责读;
* 垂直分区：把一张列比较多的表拆分为多张表。
* 水平分区：保持数据表结构不变，每一片数据分散到不同的表或者库中，分表仅仅是解决了单一表数据过大的问 题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 水平拆分最好分库。



**垂直分表和水平分表的优缺点**

垂直分表

可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。但主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用 层进行Join来解决。此外，垂直分区会让事务变得更加复杂;

水平分表

支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨节点Join 性能􏰁差，逻辑复杂



**数据库分片的两种常⻅方案**

* 客户端代理: 分片逻辑在应用端，封装在**jar**包中，通过修改或者封装**JDBC**层来实现。 当 当网的 **Sharding-JDBC** 、阿里的TDDL是两种比􏰁常用的实现。
* 中间件代理: 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我 们现在谈的 **Mycat** 、360的Atlas、网易的DDB等等都是这种架构的实现。



## 分库分表



**垂直分区**

优点：可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数

缺点：主键会出现冗余，并会引起Join操作，此外，垂直分区会让事务变得更加复杂。



**水平分区**

表的行数超过200万行时，就会变慢，这时可以把一张的表的数 据拆成多张表来存放。表结构不变，根据某种算法将数据保存到不同的数据库或表中，达到分布式存储。

缺点：分片事务难以解决；跨节点Join 性能􏰁差，逻辑复杂

尽量不要对数据进行分片，因为拆分 会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据 量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件 的网络I/O。



数据库中间价mycat



**分库分表之后,id 主键如何处理**

因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的id 来支持。

* UUID:不适合作为主键，因为太⻓了，并且无序不可读，查询效率低。比􏰁适合用于生成 唯一的名字的标示比如文件的名字。
* 数据库自增 id : 两台数据库分别设置不同步⻓，生成不重复ID的策略来实现高可用。这种方 式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。
* 利用 redis 生成 id : 性能比􏰁好，灵活方便，不依赖于数据库。但是，引入了新的组件造成 系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。
* Twitter的snowflake算法 :Github 地址:https://github.com/twitter-archive/snowflake。 美团的Leaf分布式ID生成系统 :Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、 趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系 数据库、Zookeeper等中间件。感觉还不错。美团技术团队的一篇文章:https://tech.meitua n.com/2017/04/21/mt-leaf.html 。



**limit100000分页很慢怎么解决**

* 如果id是连续的，可以通过添加where条件id>100000



**分库分表的设计**



**分布式主键设计方案**



# 缓存



# 其他



## **数据库中间件**



## 权限



**MySQL有关权限的几张表**

| 表           | 描述                             |
| ------------ | -------------------------------- |
| user         | 允许连接MySQL的账号信息          |
| db           | 记录各个账号在各个数据库少的操作 |
| table_priv   | 记录数据表级的操作权限           |
| columns_priv | 列级的操作权限                   |
| host         | 配合db权限表                     |



**SQL的生命周期**

1. 服务器与数据库建立连接
2. 数据库收到请求的SQL
3. 解析并生成执行计划执行
4. 读取数据到内存，进行逻辑处理
5. 发送结果到客户端
6. 关闭连接，释放资源



**主键使用自增Id还是UUID**

单机的可以使用自增Id，分布式的话优先考虑UUID，一般公司会有自己生成ID的方案。



**自增Id用完了怎么办**



**500台DB，在最快的时间内重启**

批量ssh工具pssh

salt或anslble



**如何监控数据库，慢日志都是怎么查询的**

通过zabbix，lepus



**数据库的六层范式**

终极目标是为了减少数据的冗余，一般情况下只有前三种范式需要满足

1NF:所有字段都是不可分割的

2NF:属性完全依赖于主键，没有部分依赖组件的属性

3NF:解决依赖传递问题





**查询缓冲**

修改配置文件开启缓冲，当查询的表和查询条件都没有变化时可以使用缓存，否则缓存失效。MySQL 8.0 版本后移除，因为这个功能不太实用，缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一 次缓存操作，失效后还要销毁。





















 




