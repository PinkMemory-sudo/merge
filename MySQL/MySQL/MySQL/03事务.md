事务日志



# TCL

Transaction Control Language

一组SQL语句组成一个单元，要么全执行，要么全失败(即失败的时候不能对数据库产生影响)。



## 事务



有些操作必须是原子性的，要成功都成功，要失败都失败，保证数据库的完整性。

**事务的四个特性**：

* 原子性 
* 一致性
* 隔离性
* 持久性



**隐式事务**

INSERT、DELETE，UPDATE、SELECT都是隐式的事务，MySQL**默认开启了自动提交**。单条语句就会提交。



**显示事务**

1. 关闭自动提交`SET AUTOCOMMIT=0`（只是关闭了当前会话的自动提交）

2. 开启事务`start transaction/BEGIN` （可选的）
3. 执行SQL语句
4. 提交/回滚事务。COMMIT/ROLLBACK

SAVEPOINT

一个事务中可以有多个 SAVEPOINT,ROLLBACK TO identifier 把事务回滚到标记点。

**事务的隔离级别**

当多个事务同时使用数据库中相同的数据时，就可能会相互影响。

***脏读***

事务T1读取到了事务T2还为提交的数据，当T2回滚时，T1读到的数据就是错误的

***不可重读***

不能重复读，重复读取到的两个值不一样。两个事务T1,T2,T1读取了一个字段的值，T2修改了该字段的值，T1再次读取该字段的值，会造成前后两个值不一致。

***幻读***

T1读取表中的字段进行统计，T2新增了记录并提交了事务，当T1在读取时就会多出来几行。与不可重读类似，不可重读时值变了，前后读取的值不相同。幻读时有新纪录插入，前后读取到的数量不同。

可以设置事务的隔离级别来解决这几个现象

***丢失数据***

​	

MySQL支持四种隔离级别

`select  @@tx_isolation;`查看隔离级别	

| 级别                       | 描述                               |
| -------------------------- | ---------------------------------- |
| 读取未提交READ UNCOMMITTED | 会导致读取未提交、不可重复读和幻读 |
| 读取已提交READ COMMITTED   | 会导致不可重读和幻读               |
| 可重复读REPEATABLE READ    | MySQL默认的，会导致幻读            |
| 串行化SERIALIZABLE         | 可以避免三个问题，但性能低         |

设置隔离级别

```mysql
SET TRANSACTION level;
```



**InnoDB解决幻读**

InnoDB默认隔离级别树可重复度，使用Next-Key lock算法避免幻读的产生。



**并发事务带来的问题**

* 赃读
* 幻读
* 不可重读
* 丢失数据







